# مستندات معماری گوگ (Goug AI Chat)

این سند معماری سطح بالای برنامه چت گوگ، تصمیمات کلیدی طراحی و جریان داده در سیستم را تشریح می‌کند. هدف این است که به توسعه‌دهندگان درک عمیقی از ساختار پروژه بدهد تا بتوانند به طور مؤثر آن را نگهداری و گسترش دهند.

## 1. نمای کلی معماری (Architectural Overview)

برنامه از یک **معماری سه لایه و رویداد-محور (Event-Driven)** در فرانت‌اند پیروی می‌کند. این سه لایه اصلی عبارتند از:

1.  **لایه رابط کاربری (UI Layer)**: مسئولیت تمام جنبه‌های بصری و تعامل با کاربر را بر عهده دارد.
2.  **لایه هسته (Core Layer)**: مغز متفکر برنامه است که منطق اصلی، مدیریت وضعیت و ارتباط با APIهای خارجی را مدیریت می‌کند.
3.  **لایه سرویس‌ها (Services Layer)**: ابزارهای کمکی و انتزاعی را برای نگرانی‌های جانبی مانند ارتباطات شبکه و ذخیره‌سازی فراهم می‌کند.

### نمودار معماری

```
+-----------------------------------------------------------------+
| کاربر (User)                                                    |
+-----------------------------------------------------------------+
      ^                                      |
      | User Interactions (clicks, input)      | DOM Updates (render)
      v                                      |
+-----------------------------------------------------------------+
| لایه رابط کاربری (UI Layer)                                     |
| [chatUI.js, messageRenderer.js, settingsModal.js, ...]          |
| - رندر کردن پیام‌ها و کامپوننت‌ها                                  |
| - دریافت ورودی‌های کاربر                                          |
| - فراخوانی متدهای عمومی Core Layer                              |
| - گوش دادن به رویدادهای Core Layer                                |
+-----------------------------------------------------------------+
      ^                                      |
      | Calls `chatEngine.sendMessage()`       | Emits Events (`message`, `chunk`, `loading`)
      v                                      |
+-----------------------------------------------------------------+
| لایه هسته (Core Layer)                                          |
| [chatEngine.js, eventEmitter.js, providers/*.js]                |
| - مدیریت وضعیت کلی برنامه (تاریخچه چت، isLoading)               |
| - ارکستراسیون و انتخاب Provider مناسب                           |
| - انتشار رویدادها برای اطلاع‌رسانی به UI Layer                   |
+-----------------------------------------------------------------+
      |                                      ^
      | Calls API / Storage methods          | Returns Data
      v                                      |
+-----------------------------------------------------------------+
| لایه سرویس‌ها (Services Layer)                                   |
| [apiService.js, storageService.js]                              |
| - انتزاعی‌سازی ارتباط با APIهای خارجی (fetch)                    |
| - مدیریت ذخیره‌سازی محلی (localStorage)                         |
+-----------------------------------------------------------------+
```

## 2. تشریح لایه‌ها

### 2.1. لایه رابط کاربری (UI Layer)

این لایه کاملاً از منطق اصلی برنامه جداست. وظیفه آن صرفاً نمایش داده‌ها و ارسال دستورات کاربر به لایه هسته است.

-   **مسئولیت‌ها**:
    -   بارگذاری قالب‌های HTML و رندر کردن کامپوننت‌ها در DOM.
    -   گرفتن رویدادهای کاربر (مانند کلیک روی دکمه ارسال یا تایپ در ورودی).
    -   فراخوانی متدهای عمومی `chatEngine` برای اجرای منطق برنامه (مثلاً `chatEngine.sendMessage(userInput)`).
    -   **اشتراک (Subscribe)** در رویدادهایی که توسط `chatEngine` منتشر می‌شود و به‌روزرسانی DOM بر اساس آن‌ها (مثلاً نمایش پیام جدید یا نشانگر تایپ).
-   **کامپوننت‌های کلیدی**: `chatUI.js`, `messageRenderer.js`, `settingsModal.js`, `sidebarManager.js`.

### 2.2. لایه هسته (Core Layer)

این لایه قلب تپنده برنامه است و هیچ وابستگی مستقیمی به DOM ندارد.

-   **مسئولیت‌ها**:
    -   نگهداری وضعیت کلی برنامه (`messages`, `isLoading`, `settings`).
    -   پیاده‌سازی منطق اصلی کسب‌وکار (ارسال پیام، ذخیره تنظیمات).
    -   استفاده از **الگوی استراتژی (Strategy Pattern)** برای انتخاب `Provider` مناسب (Gemini, OpenAI, و غیره) بر اساس تنظیمات کاربر.
    -   **انتشار (Publish)** رویدادها از طریق `EventEmitter` برای اطلاع‌رسانی به لایه‌های دیگر (مانند `UI Layer`) در مورد تغییرات وضعیت.
-   **کامپوننت‌های کلیدی**: `chatEngine.js`, `eventEmitter.js`, و تمام فایل‌های موجود در `providers/`.

### 2.3. لایه سرویس‌ها (Services Layer)

این لایه شامل ماژول‌های عمومی و قابل استفاده مجدد است که وظایف خاص و جانبی را انجام می‌دهند.

-   **مسئولیت‌ها**:
    -   **`storageService.js`**: انتزاعی‌سازی عملیات خواندن و نوشتن در `localStorage`. اگر در آینده بخواهیم مکانیزم ذخیره‌سازی را به `IndexedDB` یا یک سرور تغییر دهیم، فقط این فایل نیاز به تغییر دارد.
    -   **`apiService.js`**: مدیریت تمام ارتباطات شبکه با APIهای خارجی. این سرویس منطق تلاش مجدد (Retry Logic)، وقفه زمانی (Timeout) و پردازش استریم را پیاده‌سازی می‌کند.
-   **کامپوننت‌های کلیدی**: `apiService.js`, `storageService.js`.

## 3. معماری رویداد-محور (Event-Driven Architecture)

ارتباط اصلی بین `Core Layer` و `UI Layer` از طریق یک سیستم **Publish/Subscribe** ساده (پیاده‌سازی شده در `eventEmitter.js`) انجام می‌شود.

-   **چگونه کار می‌کند؟**
    1.  `UI Layer` در زمان مقداردهی اولیه، خود را به عنوان شنونده (Listener) برای رویدادهای مختلف `chatEngine` ثبت می‌کند (مثلاً `chatEngine.on('chunk', ...)`).
    2.  زمانی که یک عملیات در `Core Layer` رخ می‌دهد (مثلاً یک قطعه جدید از پاسخ استریم‌شده دریافت می‌شود)، `chatEngine` یک رویداد را **منتشر (emit)** می‌کند (مثلاً `chatEngine.emit('chunk', 'hello')`).
    3.  `EventEmitter` تمام شنونده‌های ثبت‌شده برای آن رویداد را فراخوانی کرده و داده‌ها را به آن‌ها ارسال می‌کند.
    4.  `UI Layer` داده‌ها را دریافت کرده و DOM را به‌روزرسانی می‌کند.

-   **مزایا**:
    -   **جداسازی کامل (Decoupling)**: `Core Layer` هیچ اطلاعی از نحوه نمایش داده‌ها ندارد و `UI Layer` هیچ اطلاعی از منطق داخلی ندارد. این به ما اجازه می‌دهد تا هر لایه را به صورت مستقل تغییر دهیم. برای مثال، می‌توانیم کل `UI Layer` را با یک فریمورک مانند React جایگزین کنیم بدون اینکه حتی یک خط از کد `Core Layer` را تغییر دهیم.

## 4. نمودار جریان یک درخواست (Request Flow Diagram)

این نمودار، مراحل کامل از زمان ارسال پیام توسط کاربر تا نمایش پاسخ را نشان می‌دهد:

```
User ---[1. تایپ و ارسال پیام]---> [ChatUI]
  |
  +-----[2. فراخوانی `chatEngine.sendMessage(text)`]---> [ChatEngine]
                                                             |
  +<----[3. انتشار رویداد `loading(true)` و `message(userMessage)`]--+
  |                                                          |
[UI به‌روزرسانی می‌شود: دکمه غیرفعال، پیام کاربر نمایش داده می‌شود]   |
                                                             V
                                                      [Provider Selector]
                                                             |
  +-----[4. انتخاب Provider مناسب (مثلاً Gemini)]---> [GeminiProvider]
                                                             |
  +-----[5. فراخوانی `apiService.fetchStreamWithRetries()`]---> [ApiService]
                                                                    |
                                                     [6. ارسال درخواست به Gemini API]
                                                                    |
  +<----[7. دریافت قطعات استریم (Chunks)]----------------------------+
  |                                                                 |
[ApiService] ---[8. پردازش و ارسال Chunk به Callback]---> [GeminiProvider]
                                                             |
  +<----[9. `onChunk(chunk)` فراخوانی می‌شود]-------------------+
  |                                                          |
[ChatEngine] ---[10. انتشار رویداد `chunk(text)`]---> [EventEmitter]
                                                             |
  +<----[11. `ChatUI` رویداد را دریافت می‌کند]-------------------+
  |
[UI به‌روزرسانی می‌شود: متن به حباب پیام دستیار اضافه می‌شود]

... (مراحل 7 تا 11 برای هر Chunk تکرار می‌شود) ...

[ApiService] ---[12. استریم تمام می‌شود]---> [ChatEngine]
                                               |
  +<---[13. انتشار `loading(false)` و `streamEnd`]--+
  |
[UI به‌روزرسانی می‌شود: دکame>