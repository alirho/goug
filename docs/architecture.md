# معماری پیک (Peik Architecture)

پیک بر اساس یک **معماری افزونه‌محور (Plugin-Based Architecture)** و **مستقل از محیط (Environment-Agnostic)** طراحی شده است. این سند فلسفه طراحی، لایه‌های سیستم و جریان داده‌ها را تشریح می‌کند.

---

## ۱. فلسفه طراحی

هدف اصلی پیک، ایجاد یک هسته هوشمند است که وابسته به هیچ پلتفرم خاصی (مانند مرورگر، Node.js یا Electron) نباشد. تمام قابلیت‌های تعاملی با دنیای بیرون (مانند ذخیره‌سازی، شبکه و رابط کاربری) به صورت **افزونه** به هسته تزریق می‌شوند.

### اصول چهارگانه معماری پیک:
1.  **Async-First**: تمامی عملیات‌های سیستم ناهمگام (Async) هستند تا از مسدود شدن Thread اصلی جلوگیری شود و سازگاری با محیط‌های مختلف تضمین گردد.
2.  **Serializable Data**: داده‌های رد و بدل شده بین هسته و افزونه‌ها باید قابل سریال‌سازی (JSON-serializable) باشند.
3.  **Isolated Communication**: اجزا فقط از طریق Interfaceها و سیستم رویداد با هم ارتباط برقرار می‌کنند.
4.  **Event-Driven**: جریان اصلی برنامه بر پایه انتشار و دریافت رویدادها بنا شده است.

---

## ۲. لایه‌بندی سیستم (System Layers)

سیستم به سه لایه اصلی تقسیم می‌شود. ارتباط این لایه‌ها در نمودار زیر نمایش داده شده است:

```
+---------------------------------------------------------------+
|               لایه ارائه (Presentation Layer)                 |
|  [WebUI Plugin]      [CLI Plugin]      [VSCode Ext Plugin]    |
+-----------------------------+---------------------------------+
                              |  ۱. فراخوانی متدها / دریافت رویدادها
                              v
+---------------------------------------------------------------+
|                  لایه هسته (Core Layer)                       |
|  [Peik (Facade)] ------------------------------------------+  |
|       |                                                    |  |
|       +---> [ChatManager] <----> [Chat (Entity)]           |  |
|       |                                                    |  |
|       +---> [SettingsManager]                              |  |
|       |                                                    |  |
|       +---> [ProviderResolver] (Service)                   |  |
|       |                                                    |  |
|       +---> [PluginManager]                                |  |
|                                                            |  |
+-----------------------------+---------------------------------+
                              |  ۲. استفاده از رابط‌های استاندارد
                              v
+---------------------------------------------------------------+
|                 لایه پلتفرم (Platform Layer)                  |
|  [IndexedDB]    [FetchHttp]    [Gemini/OpenAI Provider]       |
+---------------------------------------------------------------+
```

### لایه اول: هسته (Core)
این لایه مغز متفکر سیستم است و هیچ وابستگی خارجی ندارد. ساختار داخلی هسته برای رعایت اصل تفکیک مسئولیت‌ها (Separation of Concerns) به بخش‌های زیر تقسیم شده است:

-   **`Peik`**: کلاس اصلی که به عنوان یک **Facade** عمل می‌کند. این کلاس نقطه ورود اصلی برای افزونه‌ها و UI است و درخواست‌ها را به Manager مناسب هدایت می‌کند.
-   **Managers**: مسئول مدیریت وضعیت (State) و چرخه حیات موجودیت‌ها.
    -   `ChatManager`: مدیریت لیست گپ‌ها، ایجاد، حذف و وضعیت اجرای (Runtime) آن‌ها.
    -   `SettingsManager`: مدیریت بارگذاری، ذخیره و اعتبارسنجی تنظیمات.
    -   `PluginManager`: مدیریت ثبت و چرخه حیات افزونه‌ها.
-   **Services**: کلاس‌های Stateless که منطق خاصی را اجرا می‌کنند.
    -   `ProviderResolver`: یافتن افزونه مناسب برای یک مدل خاص.
    -   `ModelInfoHelper`: فرمت‌دهی اطلاعات مدل برای نمایش.
-   **`EventEmitter`**: سیستم ارتباطی داخلی برای انتشار رویدادها.

### لایه دوم: پلتفرم (Platform Plugins)
این لایه وظیفه ارتباط هسته با زیرساخت‌های محیط اجرا را بر عهده دارد.
-   **Storage**: پیاده‌سازی `StorageInterface`. (مانند `IndexedDBStorage` برای مرورگر یا `FileStorage` برای Node.js).
-   **Network**: پیاده‌سازی `HttpClientInterface`. (مانند `FetchHttp`).

### لایه سوم: ارائه و سرویس (Presentation & Provider Plugins)
این لایه قابلیت‌های سطح بالا را فراهم می‌کند.
-   **Providers**: اتصال به هوش مصنوعی (مانند `GeminiProvider`, `OpenAIProvider`, `CustomProvider`).
-   **Presentation**: رابط کاربری (مانند `WebUI`).

---

## ۳. جریان داده (Data Flow)

وقتی کاربر پیامی ارسال می‌کند، جریان زیر اتفاق می‌افتد:

1.  **WebUI (Input)**: کاربر پیام را تایپ و ارسال می‌کند.
2.  **Chat (Core)**: متد `sendMessage` فراخوانی می‌شود. پیام کاربر به لیست اضافه شده و رویداد `message` منتشر می‌شود.
3.  **ProviderResolver (Core)**: هسته بر اساس تنظیمات چت، افزونه مناسب (مثلاً Gemini) را پیدا می‌کند.
4.  **Provider Plugin**: پیام‌ها به افزونه Provider سپرده می‌شود.
5.  **Network Plugin**: افزونه Provider از طریق `HttpClient` درخواست را به سرور API می‌فرستد.
6.  **Streaming**: پاسخ‌ها به صورت تکه‌تکه (Chunk) دریافت شده و از طریق رویداد `chunk` به هسته و سپس به UI می‌رسند.
7.  **Storage Plugin**: پس از تکمیل پاسخ، وضعیت جدید گپ توسط `ChatManager` ذخیره می‌شود.

---

## ۴. تصمیمات معماری مهم

-   **چرا Interface؟** برای تضمین اینکه می‌توان هر افزونه‌ای را با پیاده‌سازی استاندارد جایگزین کرد (مثلاً تغییر دیتابیس بدون تغییر یک خط کد در هسته).
-   **چرا WebUI به عنوان افزونه؟** تا بتوان هسته پیک را در پروژه‌های دیگر (مثلاً یک بات تلگرام) بدون تغییر استفاده کرد و فقط افزونه رابط کاربری را تغییر داد.
-   **چرا Facade Pattern در Peik.js؟** برای ساده‌سازی API عمومی هسته. مصرف‌کنندگان هسته نیازی نیست بدانند `ChatManager` یا `SettingsManager` چگونه کار می‌کنند؛ آن‌ها فقط با متدهای `peik.createChat()` یا `peik.updateSettings()` کار می‌کنند.
